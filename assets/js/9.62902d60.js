(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{387:function(e,t,a){e.exports=a.p+"assets/img/lifecycle.931bdddc.png"},388:function(e,t,a){e.exports=a.p+"assets/img/dev-progress.6767c48b.png"},389:function(e,t,a){e.exports=a.p+"assets/img/build-progress.b92bf9ca.png"},417:function(e,t,a){"use strict";a.r(t);var o=a(9),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey},scopedSlots:e._u([{key:"diagram",fn:function(){return[o("p",[o("img",{attrs:{src:a(387),alt:"VuePress lifecycle"}})])]},proxy:!0}])},[o("p",[o("RouterLink",{attrs:{to:"/zh/2019/09/08/dive-into-vuepress-with-plugin-apis/"}},[e._v("繁體中文")]),e._v(" | English")],1),e._v(" "),o("h2",{attrs:{id:"plugin"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[e._v("#")]),e._v(" Plugin ???")]),e._v(" "),o("p",[e._v("The most important change in VuePress 1.x is "),o("code",[e._v("Pluggable")]),e._v(". VP has a lot of core functions implemented by plugins, and offers many "),o("a",{attrs:{href:"https://v1.vuepress.vuejs.org/plugin/option-api.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("options"),o("OutboundLink")],1),e._v(" for developer to build their plugins. Moreover, "),o("code",[e._v(".vuepress/config.js")]),e._v(" and "),o("code",[e._v("theme/index.js")]),e._v(" are also plugins.")]),e._v(" "),o("p",[e._v("It flashed on my mind that if I figure out the execution sequence of all the plugin APIs and what is really executed, maybe it's a special approach to understand the ins and outs of how VP works.")]),e._v(" "),o("h3",{attrs:{id:"warm-up"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#warm-up"}},[e._v("#")]),e._v(" Warm up")]),e._v(" "),o("p",[e._v("First, let's check out all the plugin options:")]),e._v(" "),o("div",{staticClass:"language-json extra-class"},[o("pre",{pre:!0,attrs:{class:"language-json"}},[o("code",[o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// hooks")]),e._v("\nready\ngenerated\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// options")]),e._v("\nchainWebpack\nextendMarkdown\nchainMarkdown\nenhanceAppFiles\nextendPageData\nclientDynamicModules\nclientRootMixin\nadditionalPages\nglobalUIComponents\ndefine\nalias\nextendCli\nbeforeDevServer\nafterDevServer\n")])])]),o("p",[e._v("I've created a diagram to show the whole life-cycle. There's a switch button at header. You can simply click it and the diagram might show up. Note that it is scrollable. Hope it will be a useful reference.")]),e._v(" "),o("h3",{attrs:{id:"how-do-plugins-work"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#how-do-plugins-work"}},[e._v("#")]),e._v(" How do plugins work")]),e._v(" "),o("p",[e._v("All the plugin options will be in initialized at the beginning. They all have their own class. You can take a look at "),o("code",[e._v("@vuepress/core/lib/node/plugin-api/abstract")]),e._v(". Later, whenever VP get the plugin config, it'll push them into each corresponding option. And at the timing you saw in my diagram, they will be executed.")]),e._v(" "),o("h2",{attrs:{id:"prepare"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#prepare"}},[e._v("#")]),e._v(" Prepare")]),e._v(" "),o("p",[e._v("We all know VP can be started by "),o("code",[e._v("vuepress dev")]),e._v(" or "),o("code",[e._v("vuepress build")]),e._v(". No matter triggered by which one, it has to enter this process. (Btw, I call it "),o("code",[e._v("Prepare")]),e._v(" because the function which handle this process in VuePress 0.x is named "),o("code",[e._v("prepare")]),e._v(")")]),e._v(" "),o("h3",{attrs:{id:"markdown"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#markdown"}},[e._v("#")]),e._v(" Markdown")]),e._v(" "),o("p",[e._v("Suppose you have already known VP uses "),o("a",{attrs:{href:"https://github.com/markdown-it/markdown-it",target:"_blank",rel:"noopener noreferrer"}},[e._v("Markdown-it"),o("OutboundLink")],1),e._v(" as the Markdown renderer.")]),e._v(" "),o("p",[e._v("The first two APIs in the life-cycle are:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("chainMarkdown")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Edit the internal Markdown config with markdown-it-chain —— A chaining API like webpack-chain but for markdown-it.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("extendMarkdown")])])]),e._v(" "),o("blockquote",[o("p",[e._v("A function to edit default config or apply extra plugins to the markdown-it instance used to render source files.")])]),e._v(" "),o("p",[e._v("First, VP has to create markdown config. VP leverages "),o("a",{attrs:{href:"https://github.com/ulivz/markdown-it-chain",target:"_blank",rel:"noopener noreferrer"}},[e._v("markdown-it-chain"),o("OutboundLink")],1),e._v(" which is developed directly on the basis of webpack-chain. In the config, VP will add a bunch of markdown-it plugins (most of them is created by VP).")]),e._v(" "),o("p",[e._v("Then, VP is going to run the plugin API "),o("code",[e._v("chainMarkdown")]),e._v(" which is going to config markdown-it as the same way above. After markdown-it-chain created a markdown-it instance with all the above configuration, VP starts to run "),o("code",[e._v("extendMarkdown")]),e._v(".")]),e._v(" "),o("p",[e._v("Those impressive features about writing Markdown might be accomplished here, such as "),o("code",[e._v("Custom Containers")]),e._v(" which offers shortcuts to create beautiful UI components, "),o("code",[e._v("Internal Links")]),e._v(" converted to "),o("code",[e._v("<router-link>")]),e._v(" for SPA navigation, "),o("a",{attrs:{href:"https://v1.vuepress.vuejs.org/guide/markdown.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("etc"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"pages"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pages"}},[e._v("#")]),e._v(" Pages")]),e._v(" "),o("p",[e._v("The next APIs I'm going to talk about are:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("extendPageData")])])]),e._v(" "),o("blockquote",[o("p",[e._v("A function used to extend or edit the $page object. This function will be invoking once for each page at compile time.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("additionalPages")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Add a page pointing to a Markdown file.")])]),e._v(" "),o("p",[e._v("Finding all page source files located in sourceDir, VP is going to resolve them. It generates the page title and headers, resolves frontmatters, and so on. This information is saved for rendering later.")]),e._v(" "),o("p",[e._v("VP will run "),o("code",[e._v("extendPageData")]),e._v(" after each page is processed. After all of that, It's time to run "),o("code",[e._v("additionalPages")]),e._v(". The pages added by "),o("code",[e._v("additionalPages")]),e._v(" will be resolve as the same way, so "),o("code",[e._v("extendPageData")]),e._v(" will also be invoked.")]),e._v(" "),o("h3",{attrs:{id:"ready"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ready"}},[e._v("#")]),e._v(" Ready")]),e._v(" "),o("p",[e._v("There're five options in this section:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("ready")])])]),e._v(" "),o("blockquote",[o("p",[e._v("The ready hook is executed after the application is initialized and before some specific functional APIs are executed.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("clientDynamicModules")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Generate some client modules at compile time.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("clientRootMixin")])])]),e._v(" "),o("blockquote",[o("p",[e._v("A path to the mixin file which allows you to control the lifecycle of root component.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("enhanceAppFiles")])])]),e._v(" "),o("blockquote",[o("p",[e._v("This option accepts absolute file path(s) pointing to the enhancement file(s), or a function that returns the path(s), which allows you to do some App Level Enhancements.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("globalUIComponents")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Inject some global UI fixed somewhere on the page.")])]),e._v(" "),o("p",[e._v("VP will run "),o("code",[e._v("ready")]),e._v(" after pages are resolved. You might be interested to know "),o("a",{attrs:{href:"https://v1.vuepress.vuejs.org/config/#styling",target:"_blank",rel:"noopener noreferrer"}},[e._v("styling"),o("OutboundLink")],1),e._v(" is completed by an internal plugin which leverages "),o("code",[e._v("ready")]),e._v(".")]),e._v(" "),o("p",[e._v("Next, run "),o("code",[e._v("clientDynamicModules")]),e._v(" the option used most often by internal plugins. That's why we can access "),o("a",{attrs:{href:"https://v1.vuepress.vuejs.org/guide/global-computed.html#global-computed",target:"_blank",rel:"noopener noreferrer"}},[e._v("Global Computed"),o("OutboundLink")],1),e._v(", use SPA navigation without manual configuration of Vue router paths and how page components or layout components be imported. Moreover, the following option "),o("code",[e._v("clientRootMixin")]),e._v(" is also handled by "),o("code",[e._v("clientDynamicModules")]),e._v(". It'll generate some temp files so that VuePress client can use them. You can simply open "),o("code",[e._v("@vuepress/core/.temp")]),e._v(" and check it out.")]),e._v(" "),o("p",[o("code",[e._v("enhanceAppFiles")]),e._v(" and "),o("code",[e._v("globalUIComponents")]),e._v(" are processed by a similar way. VuePress client will do some App Level Enhancements and register those UI components by the temp files generated by them.")]),e._v(" "),o("p",[e._v("The next following things VP will do depends on which command you actually run.")]),e._v(" "),o("h2",{attrs:{id:"custom-commands"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#custom-commands"}},[e._v("#")]),e._v(" Custom commands")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("extendCli")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Register a extra command to enhance the CLI of VuePress. The function will be called with a "),o("a",{attrs:{href:"https://github.com/cacjs/cac",target:"_blank",rel:"noopener noreferrer"}},[e._v("CAC"),o("OutboundLink")],1),e._v("'s instance as the first argument.")])]),e._v(" "),o("p",[e._v("VP leverages "),o("a",{attrs:{href:"https://github.com/cacjs/cac",target:"_blank",rel:"noopener noreferrer"}},[e._v("CAC"),o("OutboundLink")],1),e._v(" to build its Command-line Interface. Before CAC parses the arguments, VP will check node version, register "),o("a",{attrs:{href:"https://v1.vuepress.vuejs.org/api/cli.html#command-line-interface",target:"_blank",rel:"noopener noreferrer"}},[e._v("core commands"),o("OutboundLink")],1),e._v(" and handle unknown commands which is included your custom command.")]),e._v(" "),o("p",[e._v("Note that you have to tell VP where's your source files, e.g. "),o("code",[e._v("vuepress hello docs")]),e._v(". VP has to run all I've just mentioned "),o("a",{attrs:{href:"#prepare"}},[e._v("earlier")]),e._v(", otherwise it can't access "),o("code",[e._v("extendCli")]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"dev"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dev"}},[e._v("#")]),e._v(" Dev")]),e._v(" "),o("h3",{attrs:{id:"create-webpack-config"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#create-webpack-config"}},[e._v("#")]),e._v(" Create webpack config")]),e._v(" "),o("p",[e._v("VP split out webpack config into three files: base, client and server. Kind of similar to what "),o("a",{attrs:{href:"https://ssr.vuejs.org/guide/build-config.html#build-configuration",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue SSR Guide suggest"),o("OutboundLink")],1),e._v(". It'll invoke the function to create base config no matter it's creating client or server config.")]),e._v(" "),o("p",[e._v("We only need to care client config in this section:\n"),o("img",{attrs:{src:a(388),alt:"VuePress dev progress"}}),e._v("\nLet's take a look at the relevant options:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("define")])])]),e._v(" "),o("blockquote",[o("p",[e._v("VuePress opened up a concise define option, note that the values has been automatically processed by JSON.stringify.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("alias")])])]),e._v(" "),o("blockquote",[o("p",[e._v("The way to set aliases more like configuration than via "),o("code",[e._v("chainWebpack")]),e._v(".")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("chainWebpack")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Edit the internal webpack config with webpack-chain.")])]),e._v(" "),o("p",[e._v("VP is going to do a lot of things in webpack config. I'd like to mention there's a markdown loader in VP which\ntransforms "),o("code",[e._v(".md")]),e._v(" file into Vue single-file component. Since all "),o("code",[e._v(".md")]),e._v(" files are SFC, it can be handled by Vue loader.")]),e._v(" "),o("p",[e._v("Of course, VP will also create global constants and set alias at compile time. Global constants are defined for such as debugging, etc. Its relevant API "),o("code",[e._v("define")]),e._v(" is actually used by many official plugins. When processing client, VP benefits from aliases, such as accessing those temp files generated by "),o("code",[e._v("clientDynamicModules")]),e._v(".")]),e._v(" "),o("p",[e._v("In the end of creating client config, VP run "),o("code",[e._v("chainWebpack")]),e._v(" which offers the last chance to make the last config.")]),e._v(" "),o("h3",{attrs:{id:"dev-server"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dev-server"}},[e._v("#")]),e._v(" Dev server")]),e._v(" "),o("p",[e._v("VP leverages "),o("a",{attrs:{href:"https://github.com/webpack/webpack-dev-server",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-dev-server"),o("OutboundLink")],1),e._v(" to handle development.")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("beforeDevServer")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Equivalent to before in webpack-dev-server. You can use it to define custom handlers before all middleware is executed.")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("afterDevServer")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Equivalent to after in webpack-dev-server. You can use it to execute custom middleware after all other middleware.")])]),e._v(" "),o("p",[e._v("Whenever a source file is added or removed, config or frontmatters are changed, VuePress will rerun "),o("a",{attrs:{href:"#prepare"}},[e._v("Prepare")]),e._v(" to reach real hot-reload.\nSource files and config are watched by "),o("a",{attrs:{href:"https://github.com/paulmillr/chokidar",target:"_blank",rel:"noopener noreferrer"}},[e._v("chokidar"),o("OutboundLink")],1),e._v(". In the other hand, watching frontmatters are handled by the markdown loader I mentioned before.")]),e._v(" "),o("h2",{attrs:{id:"build"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#build"}},[e._v("#")]),e._v(" Build")]),e._v(" "),o("h3",{attrs:{id:"create-webpack-config-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#create-webpack-config-2"}},[e._v("#")]),e._v(" Create webpack config")]),e._v(" "),o("p",[e._v("Unlike "),o("a",{attrs:{href:"#dev"}},[e._v("Dev")]),e._v(", in this section, we do care both client and server config:")]),e._v(" "),o("p",[o("img",{attrs:{src:a(389),alt:"VuePress build progress"}})]),e._v(" "),o("p",[e._v("Those options executed by creating client config are also executed by creating server config, so we're not going to discuss them again, you can take a look at "),o("a",{attrs:{href:"#create-webpack-config"}},[e._v("the previous section")]),e._v(".")]),e._v(" "),o("p",[e._v("But there's some different config between "),o("code",[e._v("Build")]),e._v(" and "),o("code",[e._v("Dev")]),e._v(". The most important thing is using Vue SSR client and server plugin. It'll generate manifest files which provide information for rendering.")]),e._v(" "),o("h3",{attrs:{id:"generate-pages"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#generate-pages"}},[e._v("#")]),e._v(" Generate pages")]),e._v(" "),o("p",[e._v("The last option:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("generated")])])]),e._v(" "),o("blockquote",[o("p",[e._v("Called when a (production) build finishes, with an array of generated page HTML paths.")])]),e._v(" "),o("p",[e._v("What to be generate has been prepared "),o("a",{attrs:{href:"#pages"}},[e._v("earlier")]),e._v(". But before generating, VP will add a 404 page if it doesn't exist. It means VP will also run "),o("code",[e._v("extendPageData")]),e._v(".")]),e._v(" "),o("p",[e._v("When generating each file, VP will invoke "),o("a",{attrs:{href:"https://ssr.vuejs.org/api/#createbundlerenderer",target:"_blank",rel:"noopener noreferrer"}},[e._v("createBundleRenderer"),o("OutboundLink")],1),e._v(" which helps VP render HTML with those manifest files. Further infos, please head to "),o("a",{attrs:{href:"https://ssr.vuejs.org/api/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue SSR"),o("OutboundLink")],1),e._v(". Those manifest files will be removed very soon after use. That's why you've never seen them in your output folder.")]),e._v(" "),o("p",[e._v("When everything is done, VP run "),o("code",[e._v("generated")]),e._v(".✌️")]),e._v(" "),o("h2",{attrs:{id:"wrap-up"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#wrap-up"}},[e._v("#")]),e._v(" Wrap up")]),e._v(" "),o("p",[e._v("So, this approach really led me from beginning to end. Although it may not cover every concept, it saved me from thinking where should I start? Hope it can help you get clear about VP or feel more comfortable to dive into the source code.")])])}),[],!1,null,null,null);t.default=n.exports}}]);